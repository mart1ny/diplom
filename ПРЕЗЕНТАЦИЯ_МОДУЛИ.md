# Описание модулей проекта

## Видение решения

Решение: построить сервис оптимизации светофоров, который анализирует видеопотоки с камер, оценивает риск near-miss и длину очередей в реальном времени, автоматически подбирает оптимальные фазы светофора и предоставляет API/дашборд для мониторинга эффективности и качества управления движением.

**Проблемы, которые закрывает проект:**
- Перегруженные перекрёстки и длинные очереди из-за статичных расписаний светофоров.
- Повышенный риск ДТП и near-miss событий, которые незаметны в ручном мониторинге.
- Отсутствие прозрачных метрик и оперативной аналитики по работе светофорных циклов.
- Высокие затраты на ручную настройку фаз и медленная реакция на изменения трафика.

## Архитектура системы

**Захват данных и препроцессинг**
- Видео поступают из RTSP/файлов и сохраняются в `uploads/`; `scripts/pipeline_runner.TrafficPipeline` нормализует разрешение, FPS и создает Writer для аннотированного потока.
- `config.py` и `tz.txt` описывают полигоны очередей, параметры фаз и порогов, чтобы все сервисы работали в едином контексте.
- Все промежуточные артефакты (аннотированные ролики, JSONL с событиями) складываются в `results/`, что дает единый источник правды для анализа.

**Восприятие и трекинг**
- `scripts/inference.py` + YOLOv8n (`yolov8n.pt`) выполняют детекцию транспорта в реальном времени.
- `scripts/tracking.py` (SimpleKalmanTracker) поддерживает устойчивые ID, а `queue_counter.QueueCounter` для каждого кадра считает очередь по ROI.
- `rajectory_analysis.TrajectoryAnalyzer` сохраняет траектории, вычисляет скорости/углы, чтобы сформировать признаки для оценки риска.

**Риск-движок и оптимизация фаз**
- `rajectory_analysis.RiskAnalyzer` оценивает near-miss по TTC/PET и при необходимости подключает `lstm/RiskLSTMModel`.
- `traffic_optimizer.PhaseOptimizer` решает LP-задачу с учётом ограничений на цикл, штрафует риск (`lambda_risk`) и выдаёт план зелёных фаз.
- `pipeline_runner` объединяет детекцию, трекинг, риск и оптимизацию в один цикл и возвращает `queue_history`, `plan_history`, `events`.

**Хранение признаков и аналитика**
- Исторические очереди/планы сериализуются в JSONL и могут подгружаться в `lstm/demand_forecaster.py` для прогноза спроса.
- `_build_summary()` в `scripts/api_server.py` агрегирует максимальные очереди, пики риска и последний план, обеспечивая быстрый дашборд.
- При необходимости отчёты выгружаются в `progress.md` и `results/*.jsonl` для ручного анализа и A/B-сравнений.

**Оркестрация, API и UI**
- FastAPI (`scripts/api_server.py`) инстанцирует `TrafficPipeline`, принимает загрузки `/api/process-video`, возвращает ссылки на mp4/JSONL и краткие метрики.
- CLI-режим (`scripts/pipeline_runner.py`, `scripts/inference.py`) позволяет прогонять видео без сервера, что удобно для оффлайн тестов.
- `frontend/` (React) визуализирует очереди на подходах, события near-miss и рекомендуемые фазы, используя API и статические файлы из `/results`.

**Наблюдаемость и эксплуатация**
- Каждый запуск пишет структурированные логи (`logs` в ответе API) и события (TTC, risk_score, ID треков) — их можно отдавать в Prometheus-экспортёр или просто парсить в Grafana/Loki.
- Пороговые алерты (например, превышение `risk_threshold` или резкий рост очередей) формируются на стороне API и могут пересылаться в диспетчерскую систему.
- `progress.md` фиксирует изменения параметров/моделей, что служит lightweight-заменой полноценному MLflow.

## Feature Store трафика

**Хранение**
- Оффлайн: `results/*_events.jsonl`, `results/*_queues.jsonl` и `lstm/queues_sample.jsonl` содержат исторические очереди, risk-score и погодные метки для обучения LSTM и построения отчётов.
- Онлайн: `scripts/api_server.py` держит агрегаты `_build_summary()` (max_queue, risk_peaks, latest_cycle), которые React-фронт и веб-дэшборды читают в реальном времени.

**Версионирование**
- Исходные видео/ROI лежат в git/DVC, чтобы воспроизводить выборки; конфигурации признаков описаны в `config.py` и `tz.txt`, каждая правка фиксируется в `progress.md`.
- Разные версии датасетов маркируются timestamp-ом выгрузки (например, `results/2024-05-10_queues.jsonl`) и пушатся в отдельную ветку репозитория данных.

**Использование**
- `TrafficPipeline` при запуске стримит очереди в in-memory store, а `lstm/demand_forecaster.TrafficDemandDataset` берёт исторический JSONL и превращает его в сэмплы (последовательность → горизонт прогноза).
- Для аналитики и A/B тестов PhaseOptimizer выгружает `plan_history`, которые можно подмешивать к признакам (например, фактические доли зелёного).

**Синхронизация**
- Раз в день крон вызывает `pipeline_runner.py --collect-only`: свежие очереди/риски складываются в `results/` и сразу копируются в хранилище (S3/БД).
- Когда нужно обучить или откатиться — просто указываем файл выгрузки (`--data results/2024-05-10_queues.jsonl`), FastAPI читает тот же снапшот и отображает его как текущую версию.

## Данные для LSTM и EDA

**Источник:** минутные `queue_history` из `scripts/pipeline_runner.py`, сериализованные в `lstm/queues_sample.jsonl` (реальные логи будут собираться из `/api/process-video`). Ключ записи — `light_id + approach + timestamp`.

**Объём:** 4 подхода × 60 минут сутки × 7 дней ≈ 1680 строк (в демо-файле — 17 записей). Каждая строка описывает состояние подхода на конкретную минуту.

**Структура признаков**

| timestamp           | light_id        | approach | queue_len | risk | weekday | hour | is_weekend | is_holiday | weather |
|---------------------|-----------------|----------|-----------|------|---------|------|------------|------------|---------|
| 2025-12-01 07:00:00 | intersection_A  | north    | 5         | 0.12 | 1       | 7    | False      | False      | clear   |
| 2025-12-01 07:01:00 | intersection_A  | east     | 4         | 0.07 | 1       | 7    | False      | False      | clear   |
| 2025-12-01 07:03:00 | intersection_A  | north    | 9         | 0.25 | 1       | 7    | False      | False      | clouds  |

**EDA и качество**
- Пропусков: 0% (поля обязательные, валидируются при выгрузке).
- Дубликатов: 0% (контроль по ключу `timestamp+light_id+approach`).
- Целевая переменная: в LSTM прогнозируется вектор будущих очередей `queue_len[t+1 ... t+horizon]`; дополнительные признаки (`risk`, календарь, погода) кодируются one-hot в `TrafficDemandDataset`.

**Разбиение и подготовка**
- `lstm/train_demand_forecaster.py` автоматически делит сэмплы на train/val (80% / 20%) через `random_split`.
- Стандартные параметры: `seq_len=8` (последние 8 минут истории) → `horizon=3` (прогноз на 3 шага вперёд), батч 32, LSTM 2 слоя по 64 нейрона.
- В отчет `results/lstm_eval.json` (планируется) пойдут MAE/MSE по валидации и примеры прогнозов для диспетчерского отчёта.

## Модель оптимизации фаз

**Исходная модель**
- `PhaseOptimizer` из `scripts/traffic_optimizer.py` — модуль линейного распределения зелёного в реальном времени.
- Архитектура: статический цикл (`CYCLE_TIME` из `config.py`), у каждой фазы свои `min_green` и `max_green`.
- Параметры безопасности:
  - `lambda_risk=5.0` — сколько штрафа добавляем за near-miss, чтобы опасным направлениям давать больше зелёного.
  - `smoothing_alpha=0.2` — насколько быстро реагируем на изменения очередей (0 → инерция, 1 → мгновенно).
  - `max_change_ratio=0.3` — ограничение на резкое изменение длительности фазы (не более ±30% за цикл).
  - `fixed_loss_per_cycle=10.0` — секунд, которые резервируем под желтый/всех красный в каждом цикле.

**Цель и постановка задачи**
- Минимизировать остаток очередей и одновременно уменьшить риск near-miss, добавляя штраф за высокие `risk` по каждому подходу.
- Держать цикл в пределах `[cycle_min, cycle_max]`, не допускать резких скачков длительности фаз и соблюдать минимальные зелёные интервалы для ПДД.

**Процесс расчёта**
- 1) Собираем вектор очередей/рисков → считаем нагрузку `load = queue_len * weight + lambda_risk * risk`.
- 2) Сглаживаем нагрузку экспоненциальным фильтром и нормируем на доступное зелёное (`cycle - fixed_loss_per_cycle`).
- 3) Функция `_adjust_to_sum` распределяет длительности, подрезая по `min/max`, затем проверяем ограничение изменения (`max_change_ratio`) и повторяем балансировку.
- 4) Возвращаем `greens` (доли), `durations` (секунды) и прогноз остатка очередей `residual_queue`.

**Формат ввода/вывода**
- Вход: словари `queues` и `risks` с ключами-подходами (north/east/south/west).
- Выход: JSON с долями зелёного, длительностью цикла и статусом (`adaptive`), который используется в API и логах.

**Технологии и запуск**
- Написана на Python + NumPy, вызывается из `TrafficPipeline.process_video` каждые ~1 секунду (или 1 кадр).
- Все коэффициенты конфигурируются в `config.py`, поэтому можно быстро настроить другие перекрёстки без переписывания кода.

## Оценка (SUMO)

- Сценарий: SUMO-коридор с ~1.8k поездок за 30 минут (утренний пик). Сравниваем статичный план vs PhaseOptimizer, управляем фазами через TraCI.
- Методика: симулируем два прохождения (`baseline`, `opt`) и анализируем логи командой\
  `python3 analyze_kpi.py out/baseline out/opt`.
- KPI:

| Метрика                 | Baseline | Optimized | Δ / эффект                    |
|-------------------------|---------:|----------:|--------------------------------|
| Среднее время поездки   | 41.40 s  | 40.87 s   | −0.53 s (−1.3%)                |
| 95‑й перцентиль travel  | 72.00 s  | 69.00 s   | −3 s                           |
| Среднее ожидание        | 7.92 s   | 7.39 s    | −0.54 s                        |
| Общая задержка          | 13 848 s | 12 890 s  | −958 s                         |
| Средняя скорость        | 11.88 m/s| 11.96 m/s | +0.07 m/s                      |
| Lane speed avg          | 14.74 m/s| 14.83 m/s | +0.09 m/s                      |
| Lane occupancy avg      | 3.32 %   | 3.26 %    | −0.06 п.п.                     |

- Интеграционный критерий: снижение total waiting time ≥5% — модель прошла (−7%).
- План: повторить тест на реальных логах и добавить near-miss KPI (TTC violations) как дополнительный сигнал качества.

## Основные модули (scripts/)

### 1. `inference.py` — Главный пайплайн обработки видео
**Что делает:**
- Загружает YOLOv8 модель для детекции автомобилей
- Обрабатывает видео/RTSP-поток кадр за кадром
- Координирует работу всех модулей: детекция → трекинг → анализ траекторий → подсчёт очередей → анализ риска → оптимизация фаз
- Выводит результаты: аннотированное видео, логи очередей, near-miss события, рекомендации по фазам светофора

**Ключевые функции:**
- `process_video()` — основной цикл обработки
- Интеграция всех компонентов системы

---

### 2. `tracking.py` — Трекинг объектов (Kalman Filter)
**Что делает:**
- Отслеживает автомобили между кадрами, присваивая стабильные ID
- Использует фильтр Калмана для предсказания позиций
- Выполняет ассоциацию детекций с существующими треками (жадный алгоритм по расстоянию)
- Удаляет "мёртвые" треки (объекты, которые пропали на N кадров)

**Классы:**
- `TrackState` — хранит состояние трека (ID, попадания, пропуски, возраст)
- `SimpleKalmanTracker` — основной трекер с методами `update()`, `step()`, `predict()`

**Результат:** Словарь `{track_id: (x, y)}` — позиции всех отслеживаемых машин

---

### 3. `queue_counter.py` — Подсчёт очередей по ROI
**Что делает:**
- Определяет, сколько машин находится в очередях на каждом подходе (north/south/east/west)
- Использует полигоны ROI (Region of Interest) для каждого подхода
- Считает машину частью очереди, только если она находится в ROI несколько кадров подряд (фильтр шума)

**Классы:**
- `QueueCounter` — основной класс подсчёта
- `load_roi_config()` — загрузка ROI из JSON или использование дефолтных

**Результат:** Словарь `{approach: queue_length}` — длина очереди по каждому направлению

---

### 4. `rajectory_analysis.py` — Анализ траекторий и оценка риска
**Что делает:**
- Сохраняет историю движения каждого трека (координаты по кадрам)
- Вычисляет скорости и направления движения
- Находит пары машин, которые могут столкнуться (близкое расстояние)
- Рассчитывает метрики риска: **TTC (Time To Collision)** и **PET (Post-Encroachment Time)**
- Выявляет события "near-miss" (почти-аварии) на основе порогов риска

**Классы:**
- `TrajectoryAnalyzer` — хранение траекторий, вычисление скоростей/направлений
- `RiskAnalyzer` — анализ риска на основе TTC/PET
- `RiskLSTMModel` — опциональная LSTM-модель для более точной оценки риска

**Результат:** Список событий near-miss с метриками (TTC, PET, risk_score)

---

### 5. `traffic_optimizer.py` — LP-оптимизация фаз светофора
**Что делает:**
- Решает задачу линейного программирования для распределения времени зелёного сигнала
- Минимизирует: остаток очередей + штраф за риск (near-miss)
- Учитывает ограничения: min/max зелёного времени, границы длины цикла, насыщенные потоки
- Использует библиотеку `cvxpy` для решения оптимизационной задачи

**Классы:**
- `PhaseOptimizer` — оптимизатор с методом `optimize(queues, risks)`

**Результат:** План фаз светофора:
- Доли зелёного времени по каждому подходу
- Рекомендуемая длина цикла
- Ожидаемый остаток очередей после оптимизации

---

## Модули LSTM (lstm/)

### 6. `lstm/demand_forecaster.py` — LSTM-модель для прогноза загрузки
**Что делает:**
- Определяет архитектуру LSTM-сети для прогнозирования очередей на несколько шагов вперёд
- Формирует датасет из временных рядов (история очередей + календарные признаки)
- Кодирует признаки: день недели, час, погода

**Классы:**
- `TrafficDemandDataset` — PyTorch Dataset для обучения
- `TrafficDemandLSTM` — LSTM-модель (последовательность → прогноз очередей)

**Цель:** Предсказывать загрузку на основе исторических паттернов (например, "в 8 утра всегда пробка на севере")

---

### 7. `lstm/train_demand_forecaster.py` — Обучение LSTM-модели
**Что делает:**
- Загружает данные из JSONL-лога очередей
- Разделяет на train/validation
- Обучает LSTM-модель с помощью PyTorch
- Сохраняет лучшие веса модели

**Использование:**
```bash
python lstm/train_demand_forecaster.py --data lstm/queues_sample.jsonl --epochs 50
```

---

### 8. `lstm/queues_sample.jsonl` — Образец формата данных
**Что содержит:**
- Примеры записей очередей с временными метками
- Формат: `{timestamp, light_id, approach, queue_len, risk, day_of_week, hour, weather}`

**Назначение:** Шаблон для сбора реальных данных с камер

---

## Вспомогательные файлы

### `requirements.txt` — Зависимости проекта
- `ultralytics` — YOLOv8
- `opencv-python` — обработка видео
- `cvxpy` — линейное программирование
- `torch` — PyTorch для LSTM
- `numpy`, `pandas` — обработка данных

### `progress.md` — История изменений
- Фиксирует все ключевые улучшения проекта

### `README.md` — Документация проекта
- Описание системы, установка, использование

---

## Как работает система (поток данных)

```
Видео/RTSP
    ↓
[inference.py] → YOLOv8 детекция машин
    ↓
[tracking.py] → Трекинг (стабильные ID)
    ↓
[queue_counter.py] → Подсчёт очередей по ROI
    ↓
[rajectory_analysis.py] → Анализ риска (TTC/PET, near-miss)
    ↓
[traffic_optimizer.py] → LP-оптимизация фаз
    ↓
Рекомендации: {greens: {...}, cycle: 60.0}
```

**В будущем:** LSTM будет предсказывать загрузку заранее, оптимизатор будет учитывать прогноз.
